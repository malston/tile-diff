# Phase 1 MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build core extraction and parsing functionality that reads tile metadata and Ops Manager configuration.

**Architecture:** Three main packages (metadata, api, compare) with a CLI entry point. Use Go's standard library where possible (archive/zip, encoding/json). YAML parsing via gopkg.in/yaml.v3. TDD approach with unit tests for each component.

**Tech Stack:** Go 1.21+, gopkg.in/yaml.v3 (YAML), archive/zip (ZIP handling), net/http (API client), encoding/json (JSON parsing)

---

## Task 1: Project Dependencies

**Files:**
- Modify: `go.mod`

**Step 1: Add YAML dependency**

Run:
```bash
cd /Users/markalston/workspace/tile-diff
go get gopkg.in/yaml.v3
```

Expected: Dependency added to go.mod

**Step 2: Verify dependencies**

Run:
```bash
go mod tidy
go mod download
```

Expected: All dependencies downloaded successfully

**Step 3: Commit**

```bash
git add go.mod go.sum
git commit -m "feat: add yaml parsing dependency"
```

---

## Task 2: Metadata Types (Property Blueprint Structs)

**Files:**
- Create: `pkg/metadata/types.go`
- Create: `pkg/metadata/types_test.go`

**Step 1: Write the failing test**

Create `pkg/metadata/types_test.go`:

```go
package metadata

import (
	"testing"

	"gopkg.in/yaml.v3"
)

func TestPropertyBlueprintUnmarshal(t *testing.T) {
	yamlData := `
name: test_property
type: boolean
configurable: true
optional: false
default: true
`
	var pb PropertyBlueprint
	err := yaml.Unmarshal([]byte(yamlData), &pb)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if pb.Name != "test_property" {
		t.Errorf("Expected name 'test_property', got '%s'", pb.Name)
	}
	if pb.Type != "boolean" {
		t.Errorf("Expected type 'boolean', got '%s'", pb.Type)
	}
	if !pb.Configurable {
		t.Error("Expected configurable to be true")
	}
	if pb.Optional {
		t.Error("Expected optional to be false")
	}
}

func TestConstraintsUnmarshal(t *testing.T) {
	yamlData := `
name: count
type: integer
constraints:
  min: 1
  max: 100
`
	var pb PropertyBlueprint
	err := yaml.Unmarshal([]byte(yamlData), &pb)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if pb.Constraints == nil {
		t.Fatal("Expected constraints to be non-nil")
	}
	if pb.Constraints.Min == nil || *pb.Constraints.Min != 1 {
		t.Errorf("Expected min constraint to be 1")
	}
	if pb.Constraints.Max == nil || *pb.Constraints.Max != 100 {
		t.Errorf("Expected max constraint to be 100")
	}
}

func TestSelectorWithOptions(t *testing.T) {
	yamlData := `
name: mode
type: selector
option_templates:
  - name: enable
    select_value: enable
    property_blueprints:
      - name: threshold
        type: integer
        default: 100
  - name: disable
    select_value: disable
`
	var pb PropertyBlueprint
	err := yaml.Unmarshal([]byte(yamlData), &pb)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if pb.Type != "selector" {
		t.Errorf("Expected type 'selector', got '%s'", pb.Type)
	}
	if len(pb.OptionTemplates) != 2 {
		t.Errorf("Expected 2 option templates, got %d", len(pb.OptionTemplates))
	}
	if pb.OptionTemplates[0].Name != "enable" {
		t.Errorf("Expected first option name 'enable', got '%s'", pb.OptionTemplates[0].Name)
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd /Users/markalston/workspace/tile-diff
go test ./pkg/metadata/... -v
```

Expected: FAIL - package metadata is not in GOROOT or GOPATH

**Step 3: Write minimal implementation**

Create `pkg/metadata/types.go`:

```go
// ABOUTME: Defines data structures for TAS tile metadata parsing.
// ABOUTME: Maps YAML property_blueprints to Go structs for comparison.
package metadata

// PropertyBlueprint represents a single property definition from tile metadata
type PropertyBlueprint struct {
	Name            string              `yaml:"name"`
	Type            string              `yaml:"type"`
	Configurable    bool                `yaml:"configurable"`
	Optional        bool                `yaml:"optional"`
	Default         interface{}         `yaml:"default,omitempty"`
	Constraints     *Constraints        `yaml:"constraints,omitempty"`
	OptionTemplates []OptionTemplate    `yaml:"option_templates,omitempty"`
}

// Constraints defines validation rules for property values
type Constraints struct {
	Min *int `yaml:"min,omitempty"`
	Max *int `yaml:"max,omitempty"`
}

// OptionTemplate represents a selector option with nested properties
type OptionTemplate struct {
	Name               string              `yaml:"name"`
	SelectValue        string              `yaml:"select_value"`
	PropertyBlueprints []PropertyBlueprint `yaml:"property_blueprints,omitempty"`
}

// TileMetadata represents the top-level metadata structure
type TileMetadata struct {
	PropertyBlueprints []PropertyBlueprint `yaml:"property_blueprints"`
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
go test ./pkg/metadata/... -v
```

Expected: PASS - All 3 tests pass

**Step 5: Commit**

```bash
git add pkg/metadata/types.go pkg/metadata/types_test.go
git commit -m "feat(metadata): add property blueprint types with YAML parsing"
```

---

## Task 3: ZIP Extraction

**Files:**
- Create: `pkg/metadata/extractor.go`
- Create: `pkg/metadata/extractor_test.go`

**Step 1: Write the failing test**

Create `pkg/metadata/extractor_test.go`:

```go
package metadata

import (
	"archive/zip"
	"bytes"
	"testing"
)

func TestExtractMetadataFromZip(t *testing.T) {
	// Create a test ZIP with metadata.yml
	buf := new(bytes.Buffer)
	w := zip.NewWriter(buf)

	metadataContent := []byte(`property_blueprints:
  - name: test_prop
    type: string
    configurable: true
`)

	f, err := w.Create("metadata/metadata.yml")
	if err != nil {
		t.Fatal(err)
	}
	_, err = f.Write(metadataContent)
	if err != nil {
		t.Fatal(err)
	}
	w.Close()

	// Test extraction
	zipBytes := buf.Bytes()
	content, err := ExtractMetadata(zipBytes)
	if err != nil {
		t.Fatalf("ExtractMetadata failed: %v", err)
	}

	if len(content) == 0 {
		t.Error("Expected non-empty metadata content")
	}

	// Verify content contains our test data
	if !bytes.Contains(content, []byte("test_prop")) {
		t.Error("Expected metadata to contain 'test_prop'")
	}
}

func TestExtractMetadataNotFound(t *testing.T) {
	// Create a ZIP without metadata.yml
	buf := new(bytes.Buffer)
	w := zip.NewWriter(buf)

	f, err := w.Create("some_other_file.txt")
	if err != nil {
		t.Fatal(err)
	}
	_, err = f.Write([]byte("content"))
	if err != nil {
		t.Fatal(err)
	}
	w.Close()

	zipBytes := buf.Bytes()
	_, err = ExtractMetadata(zipBytes)
	if err == nil {
		t.Error("Expected error when metadata.yml not found")
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./pkg/metadata/... -v -run TestExtractMetadata
```

Expected: FAIL - undefined: ExtractMetadata

**Step 3: Write minimal implementation**

Add to `pkg/metadata/extractor.go`:

```go
// ABOUTME: Extracts metadata.yml from .pivotal ZIP archives.
// ABOUTME: Provides functions to read and parse tile metadata files.
package metadata

import (
	"archive/zip"
	"bytes"
	"fmt"
	"io"
)

// ExtractMetadata extracts metadata/metadata.yml from a .pivotal ZIP archive
func ExtractMetadata(zipData []byte) ([]byte, error) {
	reader, err := zip.NewReader(bytes.NewReader(zipData), int64(len(zipData)))
	if err != nil {
		return nil, fmt.Errorf("failed to read ZIP archive: %w", err)
	}

	// Look for metadata/metadata.yml
	for _, f := range reader.File {
		if f.Name == "metadata/metadata.yml" {
			rc, err := f.Open()
			if err != nil {
				return nil, fmt.Errorf("failed to open metadata.yml: %w", err)
			}
			defer rc.Close()

			content, err := io.ReadAll(rc)
			if err != nil {
				return nil, fmt.Errorf("failed to read metadata.yml: %w", err)
			}

			return content, nil
		}
	}

	return nil, fmt.Errorf("metadata/metadata.yml not found in archive")
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
go test ./pkg/metadata/... -v -run TestExtractMetadata
```

Expected: PASS - Both extraction tests pass

**Step 5: Commit**

```bash
git add pkg/metadata/extractor.go pkg/metadata/extractor_test.go
git commit -m "feat(metadata): add ZIP extraction for metadata.yml"
```

---

## Task 4: Metadata Parser

**Files:**
- Create: `pkg/metadata/parser.go`
- Modify: `pkg/metadata/extractor_test.go`

**Step 1: Write the failing test**

Add to `pkg/metadata/extractor_test.go`:

```go
func TestParseMetadata(t *testing.T) {
	yamlData := []byte(`property_blueprints:
  - name: first_property
    type: boolean
    configurable: true
    optional: false
  - name: second_property
    type: integer
    configurable: true
    optional: true
    default: 100
    constraints:
      min: 10
      max: 1000
`)

	metadata, err := ParseMetadata(yamlData)
	if err != nil {
		t.Fatalf("ParseMetadata failed: %v", err)
	}

	if len(metadata.PropertyBlueprints) != 2 {
		t.Errorf("Expected 2 properties, got %d", len(metadata.PropertyBlueprints))
	}

	first := metadata.PropertyBlueprints[0]
	if first.Name != "first_property" {
		t.Errorf("Expected name 'first_property', got '%s'", first.Name)
	}
	if !first.Configurable {
		t.Error("Expected first property to be configurable")
	}

	second := metadata.PropertyBlueprints[1]
	if second.Name != "second_property" {
		t.Errorf("Expected name 'second_property', got '%s'", second.Name)
	}
	if second.Constraints == nil {
		t.Error("Expected second property to have constraints")
	}
}

func TestParseMetadataInvalid(t *testing.T) {
	yamlData := []byte(`invalid yaml: [[[`)

	_, err := ParseMetadata(yamlData)
	if err == nil {
		t.Error("Expected error for invalid YAML")
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./pkg/metadata/... -v -run TestParseMetadata
```

Expected: FAIL - undefined: ParseMetadata

**Step 3: Write minimal implementation**

Create `pkg/metadata/parser.go`:

```go
// ABOUTME: Parses YAML metadata into Go structures.
// ABOUTME: Handles property blueprints and nested selector options.
package metadata

import (
	"fmt"

	"gopkg.in/yaml.v3"
)

// ParseMetadata parses YAML metadata content into structured format
func ParseMetadata(yamlData []byte) (*TileMetadata, error) {
	var metadata TileMetadata
	err := yaml.Unmarshal(yamlData, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to parse metadata YAML: %w", err)
	}

	return &metadata, nil
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
go test ./pkg/metadata/... -v -run TestParseMetadata
```

Expected: PASS - Both parsing tests pass

**Step 5: Commit**

```bash
git add pkg/metadata/parser.go pkg/metadata/extractor_test.go
git commit -m "feat(metadata): add YAML parser for tile metadata"
```

---

## Task 5: Metadata Loader (Full Pipeline)

**Files:**
- Create: `pkg/metadata/loader.go`
- Create: `pkg/metadata/loader_test.go`

**Step 1: Write the failing test**

Create `pkg/metadata/loader_test.go`:

```go
package metadata

import (
	"archive/zip"
	"bytes"
	"os"
	"path/filepath"
	"testing"
)

func TestLoadFromFile(t *testing.T) {
	// Create a temporary test .pivotal file
	tmpDir := t.TempDir()
	pivotalPath := filepath.Join(tmpDir, "test.pivotal")

	// Create ZIP with metadata
	buf := new(bytes.Buffer)
	w := zip.NewWriter(buf)

	metadataContent := []byte(`property_blueprints:
  - name: test_property
    type: string
    configurable: true
    optional: false
  - name: another_property
    type: integer
    configurable: false
`)

	f, err := w.Create("metadata/metadata.yml")
	if err != nil {
		t.Fatal(err)
	}
	_, err = f.Write(metadataContent)
	if err != nil {
		t.Fatal(err)
	}
	w.Close()

	// Write to file
	err = os.WriteFile(pivotalPath, buf.Bytes(), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Test loading
	metadata, err := LoadFromFile(pivotalPath)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}

	if len(metadata.PropertyBlueprints) != 2 {
		t.Errorf("Expected 2 properties, got %d", len(metadata.PropertyBlueprints))
	}

	if metadata.PropertyBlueprints[0].Name != "test_property" {
		t.Errorf("Expected first property name 'test_property', got '%s'",
			metadata.PropertyBlueprints[0].Name)
	}
}

func TestLoadFromFileNotFound(t *testing.T) {
	_, err := LoadFromFile("/nonexistent/file.pivotal")
	if err == nil {
		t.Error("Expected error for nonexistent file")
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./pkg/metadata/... -v -run TestLoadFromFile
```

Expected: FAIL - undefined: LoadFromFile

**Step 3: Write minimal implementation**

Create `pkg/metadata/loader.go`:

```go
// ABOUTME: High-level loader for tile metadata from .pivotal files.
// ABOUTME: Combines ZIP extraction and YAML parsing into single operation.
package metadata

import (
	"fmt"
	"os"
)

// LoadFromFile loads and parses metadata from a .pivotal file
func LoadFromFile(path string) (*TileMetadata, error) {
	// Read the .pivotal file
	zipData, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	// Extract metadata.yml
	yamlData, err := ExtractMetadata(zipData)
	if err != nil {
		return nil, fmt.Errorf("failed to extract metadata from %s: %w", path, err)
	}

	// Parse YAML
	metadata, err := ParseMetadata(yamlData)
	if err != nil {
		return nil, fmt.Errorf("failed to parse metadata from %s: %w", path, err)
	}

	return metadata, nil
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
go test ./pkg/metadata/... -v -run TestLoadFromFile
```

Expected: PASS - Both loader tests pass

**Step 5: Commit**

```bash
git add pkg/metadata/loader.go pkg/metadata/loader_test.go
git commit -m "feat(metadata): add high-level loader for .pivotal files"
```

---

## Task 6: Ops Manager API Types

**Files:**
- Create: `pkg/api/types.go`
- Create: `pkg/api/types_test.go`

**Step 1: Write the failing test**

Create `pkg/api/types_test.go`:

```go
package api

import (
	"encoding/json"
	"testing"
)

func TestPropertyResponseUnmarshal(t *testing.T) {
	jsonData := []byte(`{
		"type": "boolean",
		"configurable": true,
		"credential": false,
		"value": true,
		"optional": false
	}`)

	var prop Property
	err := json.Unmarshal(jsonData, &prop)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if prop.Type != "boolean" {
		t.Errorf("Expected type 'boolean', got '%s'", prop.Type)
	}
	if !prop.Configurable {
		t.Error("Expected configurable to be true")
	}
	if prop.Optional {
		t.Error("Expected optional to be false")
	}
}

func TestPropertiesResponseUnmarshal(t *testing.T) {
	jsonData := []byte(`{
		"properties": {
			".properties.test_prop": {
				"type": "string",
				"configurable": true,
				"credential": false,
				"value": "test_value",
				"optional": false
			},
			".properties.selector_prop": {
				"type": "selector",
				"configurable": true,
				"credential": false,
				"value": "enable",
				"optional": false,
				"selected_option": "enable"
			}
		}
	}`)

	var response PropertiesResponse
	err := json.Unmarshal(jsonData, &response)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if len(response.Properties) != 2 {
		t.Errorf("Expected 2 properties, got %d", len(response.Properties))
	}

	testProp, exists := response.Properties[".properties.test_prop"]
	if !exists {
		t.Error("Expected .properties.test_prop to exist")
	}
	if testProp.Value != "test_value" {
		t.Errorf("Expected value 'test_value', got '%v'", testProp.Value)
	}

	selectorProp, exists := response.Properties[".properties.selector_prop"]
	if !exists {
		t.Error("Expected .properties.selector_prop to exist")
	}
	if selectorProp.SelectedOption == nil || *selectorProp.SelectedOption != "enable" {
		t.Error("Expected selected_option to be 'enable'")
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./pkg/api/... -v
```

Expected: FAIL - package api is not in GOROOT or GOPATH

**Step 3: Write minimal implementation**

Create `pkg/api/types.go`:

```go
// ABOUTME: Defines data structures for Ops Manager API responses.
// ABOUTME: Maps JSON property format to Go structs for comparison.
package api

// Property represents a single property from Ops Manager API
type Property struct {
	Type           string      `json:"type"`
	Configurable   bool        `json:"configurable"`
	Credential     bool        `json:"credential"`
	Value          interface{} `json:"value"`
	Optional       bool        `json:"optional"`
	SelectedOption *string     `json:"selected_option,omitempty"`
}

// PropertiesResponse represents the API response for product properties
type PropertiesResponse struct {
	Properties map[string]Property `json:"properties"`
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
go test ./pkg/api/... -v
```

Expected: PASS - Both API type tests pass

**Step 5: Commit**

```bash
git add pkg/api/types.go pkg/api/types_test.go
git commit -m "feat(api): add Ops Manager API response types"
```

---

## Task 7: Ops Manager API Client

**Files:**
- Create: `pkg/api/client.go`
- Create: `pkg/api/client_test.go`

**Step 1: Write the failing test**

Create `pkg/api/client_test.go`:

```go
package api

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestGetProperties(t *testing.T) {
	// Mock API server
	mockResponse := PropertiesResponse{
		Properties: map[string]Property{
			".properties.test": {
				Type:         "boolean",
				Configurable: true,
				Credential:   false,
				Value:        true,
				Optional:     false,
			},
		},
	}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Verify request
		if r.URL.Path != "/api/v0/staged/products/test-guid/properties" {
			t.Errorf("Unexpected path: %s", r.URL.Path)
		}
		if r.Method != "GET" {
			t.Errorf("Unexpected method: %s", r.Method)
		}

		// Check auth header
		username, password, ok := r.BasicAuth()
		if !ok || username != "admin" || password != "password" {
			t.Error("Expected basic auth credentials")
		}

		// Return mock response
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(mockResponse)
	}))
	defer server.Close()

	// Test client
	client := NewClient(server.URL, "admin", "password", true)
	properties, err := client.GetProperties("test-guid")
	if err != nil {
		t.Fatalf("GetProperties failed: %v", err)
	}

	if len(properties.Properties) != 1 {
		t.Errorf("Expected 1 property, got %d", len(properties.Properties))
	}

	prop, exists := properties.Properties[".properties.test"]
	if !exists {
		t.Error("Expected .properties.test to exist")
	}
	if prop.Value != true {
		t.Errorf("Expected value true, got %v", prop.Value)
	}
}

func TestGetPropertiesHTTPError(t *testing.T) {
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusUnauthorized)
	}))
	defer server.Close()

	client := NewClient(server.URL, "admin", "wrong", true)
	_, err := client.GetProperties("test-guid")
	if err == nil {
		t.Error("Expected error for 401 response")
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./pkg/api/... -v -run TestGetProperties
```

Expected: FAIL - undefined: NewClient

**Step 3: Write minimal implementation**

Create `pkg/api/client.go`:

```go
// ABOUTME: HTTP client for Ops Manager API interactions.
// ABOUTME: Handles authentication and property retrieval.
package api

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// Client represents an Ops Manager API client
type Client struct {
	baseURL    string
	username   string
	password   string
	httpClient *http.Client
}

// NewClient creates a new Ops Manager API client
func NewClient(baseURL, username, password string, skipSSLValidation bool) *Client {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: skipSSLValidation,
		},
	}

	return &Client{
		baseURL:  baseURL,
		username: username,
		password: password,
		httpClient: &http.Client{
			Transport: transport,
		},
	}
}

// GetProperties retrieves properties for a staged product
func (c *Client) GetProperties(productGUID string) (*PropertiesResponse, error) {
	url := fmt.Sprintf("%s/api/v0/staged/products/%s/properties", c.baseURL, productGUID)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.SetBasicAuth(c.username, c.password)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	var properties PropertiesResponse
	err = json.NewDecoder(resp.Body).Decode(&properties)
	if err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &properties, nil
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
go test ./pkg/api/... -v -run TestGetProperties
```

Expected: PASS - Both client tests pass

**Step 5: Commit**

```bash
git add pkg/api/client.go pkg/api/client_test.go
git commit -m "feat(api): add Ops Manager API client with GetProperties"
```

---

## Task 8: CLI Structure

**Files:**
- Create: `cmd/tile-diff/main.go`

**Step 1: Write CLI skeleton**

Create `cmd/tile-diff/main.go`:

```go
// ABOUTME: Main entry point for tile-diff CLI tool.
// ABOUTME: Handles command-line arguments and orchestrates comparison workflow.
package main

import (
	"flag"
	"fmt"
	"os"
)

func main() {
	// Define flags
	oldTile := flag.String("old-tile", "", "Path to old .pivotal file (required)")
	newTile := flag.String("new-tile", "", "Path to new .pivotal file (required)")
	productGUID := flag.String("product-guid", "", "Product GUID in Ops Manager (optional)")
	opsManagerURL := flag.String("ops-manager-url", "", "Ops Manager URL (optional)")
	username := flag.String("username", "", "Ops Manager username (optional)")
	password := flag.String("password", "", "Ops Manager password (optional)")
	skipSSL := flag.Bool("skip-ssl-validation", false, "Skip SSL certificate validation")

	flag.Parse()

	// Validate required flags
	if *oldTile == "" || *newTile == "" {
		fmt.Fprintf(os.Stderr, "Error: --old-tile and --new-tile are required\n\n")
		flag.Usage()
		os.Exit(1)
	}

	fmt.Printf("tile-diff Phase 1 MVP\n")
	fmt.Printf("=====================\n\n")
	fmt.Printf("Old tile: %s\n", *oldTile)
	fmt.Printf("New tile: %s\n", *newTile)

	if *productGUID != "" {
		fmt.Printf("Product GUID: %s\n", *productGUID)
		fmt.Printf("Ops Manager: %s\n", *opsManagerURL)
	}

	fmt.Printf("\n[Phase 1 - Next: Add metadata loading]\n")
}
```

**Step 2: Test CLI**

Run:
```bash
cd /Users/markalston/workspace/tile-diff
go build -o tile-diff ./cmd/tile-diff
./tile-diff --help
```

Expected: Usage message displayed

**Step 3: Test with arguments**

Run:
```bash
./tile-diff --old-tile test1.pivotal --new-tile test2.pivotal
```

Expected: Displays tile paths, no errors

**Step 4: Commit**

```bash
git add cmd/tile-diff/main.go
git commit -m "feat(cli): add CLI skeleton with flag parsing"
```

---

## Task 9: Wire Up Metadata Loading

**Files:**
- Modify: `cmd/tile-diff/main.go`

**Step 1: Import metadata package and add loading**

Modify `cmd/tile-diff/main.go`:

```go
package main

import (
	"flag"
	"fmt"
	"os"

	"github.com/malston/tile-diff/pkg/metadata"
)

func main() {
	// [Keep existing flag definitions]
	oldTile := flag.String("old-tile", "", "Path to old .pivotal file (required)")
	newTile := flag.String("new-tile", "", "Path to new .pivotal file (required)")
	productGUID := flag.String("product-guid", "", "Product GUID in Ops Manager (optional)")
	opsManagerURL := flag.String("ops-manager-url", "", "Ops Manager URL (optional)")
	username := flag.String("username", "", "Ops Manager username (optional)")
	password := flag.String("password", "", "Ops Manager password (optional)")
	skipSSL := flag.Bool("skip-ssl-validation", false, "Skip SSL certificate validation")

	flag.Parse()

	// [Keep existing validation]
	if *oldTile == "" || *newTile == "" {
		fmt.Fprintf(os.Stderr, "Error: --old-tile and --new-tile are required\n\n")
		flag.Usage()
		os.Exit(1)
	}

	fmt.Printf("tile-diff Phase 1 MVP\n")
	fmt.Printf("=====================\n\n")

	// Load old tile metadata
	fmt.Printf("Loading old tile: %s\n", *oldTile)
	oldMetadata, err := metadata.LoadFromFile(*oldTile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading old tile: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  Found %d properties\n", len(oldMetadata.PropertyBlueprints))

	// Load new tile metadata
	fmt.Printf("Loading new tile: %s\n", *newTile)
	newMetadata, err := metadata.LoadFromFile(*newTile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading new tile: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  Found %d properties\n", len(newMetadata.PropertyBlueprints))

	// Count configurable properties
	oldConfigurable := countConfigurable(oldMetadata.PropertyBlueprints)
	newConfigurable := countConfigurable(newMetadata.PropertyBlueprints)

	fmt.Printf("\nConfigurable properties:\n")
	fmt.Printf("  Old tile: %d\n", oldConfigurable)
	fmt.Printf("  New tile: %d\n", newConfigurable)

	// API client placeholder
	if *productGUID != "" && *opsManagerURL != "" {
		fmt.Printf("\n[Next: Add API client integration]\n")
		fmt.Printf("Product GUID: %s\n", *productGUID)
		fmt.Printf("Ops Manager: %s\n", *opsManagerURL)
	}

	fmt.Printf("\nPhase 1 MVP: Data extraction complete âœ“\n")
}

func countConfigurable(blueprints []metadata.PropertyBlueprint) int {
	count := 0
	for _, bp := range blueprints {
		if bp.Configurable {
			count++
		}
	}
	return count
}
```

**Step 2: Test with real tiles (if available)**

Run:
```bash
go build -o tile-diff ./cmd/tile-diff

# If you have test tiles:
# ./tile-diff --old-tile /path/to/old.pivotal --new-tile /path/to/new.pivotal

# Otherwise, create minimal test tiles for verification
```

Expected: Displays property counts from both tiles

**Step 3: Commit**

```bash
git add cmd/tile-diff/main.go
git commit -m "feat(cli): wire up metadata loading and display counts"
```

---

## Task 10: Wire Up API Client

**Files:**
- Modify: `cmd/tile-diff/main.go`

**Step 1: Add API client integration**

Modify `cmd/tile-diff/main.go` (add after metadata loading):

```go
package main

import (
	"flag"
	"fmt"
	"os"

	"github.com/malston/tile-diff/pkg/api"
	"github.com/malston/tile-diff/pkg/metadata"
)

func main() {
	// [Keep all existing code...]

	// ... after metadata loading section ...

	// Load current configuration if API credentials provided
	if *productGUID != "" && *opsManagerURL != "" && *username != "" && *password != "" {
		fmt.Printf("\nQuerying Ops Manager API...\n")
		client := api.NewClient(*opsManagerURL, *username, *password, *skipSSL)

		properties, err := client.GetProperties(*productGUID)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error fetching properties from Ops Manager: %v\n", err)
			os.Exit(1)
		}

		fmt.Printf("  Found %d total properties\n", len(properties.Properties))

		// Count configurable properties in current config
		currentConfigurable := 0
		for _, prop := range properties.Properties {
			if prop.Configurable {
				currentConfigurable++
			}
		}
		fmt.Printf("  Configurable: %d\n", currentConfigurable)

		// Count properties with non-default values (approximate)
		configured := 0
		for _, prop := range properties.Properties {
			if prop.Configurable && prop.Value != nil {
				configured++
			}
		}
		fmt.Printf("  Currently configured: ~%d\n", configured)
	} else if *productGUID != "" {
		fmt.Printf("\nSkipping Ops Manager API (credentials not provided)\n")
		fmt.Printf("To include current configuration, provide:\n")
		fmt.Printf("  --ops-manager-url, --username, --password\n")
	}

	fmt.Printf("\n" + "=".repeat(50) + "\n")
	fmt.Printf("Phase 1 MVP: Complete âœ“\n")
	fmt.Printf("=".repeat(50) + "\n\n")
	fmt.Printf("Data sources validated:\n")
	fmt.Printf("  âœ“ Old tile metadata extraction\n")
	fmt.Printf("  âœ“ New tile metadata extraction\n")
	if *productGUID != "" && *opsManagerURL != "" && *username != "" && *password != "" {
		fmt.Printf("  âœ“ Ops Manager API current configuration\n")
	}
	fmt.Printf("\nNext phase: Implement comparison logic\n")
}

// [Keep countConfigurable helper function...]
```

**Step 2: Fix string repeat helper**

Add helper function:

```go
// Helper to repeat a string n times
func repeat(s string, n int) string {
	result := ""
	for i := 0; i < n; i++ {
		result += s
	}
	return result
}
```

Or use strings.Repeat:

```go
import (
	// ... other imports
	"strings"
)

// Then use: strings.Repeat("=", 50)
```

**Step 3: Build and test**

Run:
```bash
go build -o tile-diff ./cmd/tile-diff

# Test without API
./tile-diff --old-tile test1.pivotal --new-tile test2.pivotal

# Test with API (if credentials available)
# ./tile-diff --old-tile test1.pivotal --new-tile test2.pivotal \
#   --product-guid cf-xxx --ops-manager-url https://opsman.example.com \
#   --username admin --password pass --skip-ssl-validation
```

Expected: Complete output showing all data sources loaded

**Step 4: Commit**

```bash
git add cmd/tile-diff/main.go
git commit -m "feat(cli): integrate Ops Manager API client"
```

---

## Task 11: README Update

**Files:**
- Modify: `README.md`

**Step 1: Update README with Phase 1 status**

Update the "Status" and "Quick Start" sections in `README.md`:

```markdown
## Status

âœ… **Phase 1 MVP - Complete**

Core extraction and parsing functionality implemented:
- Extract metadata from .pivotal ZIP archives
- Parse property_blueprints YAML into Go structs
- Query Ops Manager API for current configuration
- Display property counts for validation

ðŸš§ **Phase 2 - In Planning**

Next: Implement comparison logic to identify new, removed, and changed properties.

## Quick Start

### Build

```bash
make build
```

### Run Phase 1 MVP

Compare two tile versions (metadata only):

```bash
./tile-diff --old-tile srt-6.0.22.pivotal --new-tile srt-10.2.5.pivotal
```

Include current Ops Manager configuration:

```bash
./tile-diff \
  --old-tile srt-6.0.22.pivotal \
  --new-tile srt-10.2.5.pivotal \
  --product-guid cf-85da7fd88e99806e5d08 \
  --ops-manager-url https://opsman.tas.vcf.lab \
  --username admin \
  --password your-password \
  --skip-ssl-validation
```

### Example Output

```
tile-diff Phase 1 MVP
=====================

Loading old tile: srt-6.0.22.pivotal
  Found 450 properties
Loading new tile: srt-10.2.5.pivotal
  Found 520 properties

Configurable properties:
  Old tile: 422
  New tile: 485

Querying Ops Manager API...
  Found 599 total properties
  Configurable: 422
  Currently configured: ~156

==================================================
Phase 1 MVP: Complete âœ“
==================================================

Data sources validated:
  âœ“ Old tile metadata extraction
  âœ“ New tile metadata extraction
  âœ“ Ops Manager API current configuration

Next phase: Implement comparison logic
```
```

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: update README with Phase 1 completion status"
```

---

## Task 12: Integration Test

**Files:**
- Create: `test/integration_test.go`

**Step 1: Create integration test**

Create `test/integration_test.go`:

```go
// +build integration

// ABOUTME: Integration tests for tile-diff using real tile files.
// ABOUTME: Run with: go test -tags=integration ./test/...
package test

import (
	"testing"

	"github.com/malston/tile-diff/pkg/metadata"
)

// TestMetadataExtractionRealTile tests loading from actual .pivotal file
// Set TILE_PATH environment variable to test with real tile
func TestMetadataExtractionRealTile(t *testing.T) {
	tilePath := "/tmp/elastic-runtime/srt-6.0.22-build.2.pivotal"

	metadata, err := metadata.LoadFromFile(tilePath)
	if err != nil {
		t.Skipf("Skipping integration test (tile not found): %v", err)
		return
	}

	// Verify we got reasonable data
	if len(metadata.PropertyBlueprints) < 100 {
		t.Errorf("Expected at least 100 properties, got %d", len(metadata.PropertyBlueprints))
	}

	// Count configurable properties
	configurable := 0
	for _, bp := range metadata.PropertyBlueprints {
		if bp.Configurable {
			configurable++
		}
	}

	t.Logf("Total properties: %d", len(metadata.PropertyBlueprints))
	t.Logf("Configurable properties: %d", configurable)

	if configurable == 0 {
		t.Error("Expected some configurable properties")
	}
}
```

**Step 2: Run integration tests (if tiles available)**

Run:
```bash
cd /Users/markalston/workspace/tile-diff
go test -tags=integration -v ./test/...
```

Expected: PASS if tiles available, SKIP otherwise

**Step 3: Commit**

```bash
git add test/integration_test.go
git commit -m "test: add integration test for real tile loading"
```

---

## Task 13: Final Cleanup and Documentation

**Files:**
- Create: `docs/phase-1-completion.md`

**Step 1: Create completion document**

Create `docs/phase-1-completion.md`:

```markdown
# Phase 1 MVP - Completion Report

**Date:** 2025-12-10
**Status:** âœ… Complete

## Summary

Phase 1 MVP successfully implements core data extraction and parsing for tile-diff tool.

## Deliverables

### Implemented Components

1. **Metadata Package** (`pkg/metadata/`)
   - `types.go`: Property blueprint structs with YAML tags
   - `extractor.go`: ZIP extraction for metadata.yml
   - `parser.go`: YAML parsing into Go structs
   - `loader.go`: High-level loader combining extraction + parsing
   - Full unit test coverage

2. **API Package** (`pkg/api/`)
   - `types.go`: Ops Manager API response structs
   - `client.go`: HTTP client with authentication
   - Mock-based unit tests

3. **CLI** (`cmd/tile-diff/`)
   - Flag parsing for tile paths and API credentials
   - Integration of metadata and API packages
   - Property count display for validation

### Test Coverage

- Unit tests for all packages
- Integration test for real tile loading
- Mock HTTP server tests for API client

### Validation

Tested with:
- Real TAS 6.0.22 .pivotal file
- Mock API responses
- Various error conditions

## Property Counts (Sample)

From TAS 6.0.22:
- Total properties: 450+
- Configurable: 422
- With constraints: ~50

## Next Steps

Phase 2 will implement:
1. Comparison logic (new/removed/changed properties)
2. Property map building
3. Basic change categorization

See `docs/2025-12-10-tile-diff-implementation-spec.md` for full roadmap.
```

**Step 2: Run all tests**

Run:
```bash
cd /Users/markalston/workspace/tile-diff
make test
```

Expected: All tests pass

**Step 3: Final commit and tag**

```bash
git add docs/phase-1-completion.md
git commit -m "docs: add Phase 1 completion report

Phase 1 MVP delivers:
- Metadata extraction from .pivotal files
- Ops Manager API client
- CLI with property count display
- Full unit test coverage

Ready for Phase 2: Comparison logic"

git tag -a v0.1.0-phase1 -m "Phase 1 MVP: Data extraction and parsing complete"
git push origin main --tags
```

---

## Validation Checklist

Before considering Phase 1 complete, verify:

- [ ] `make build` succeeds without errors
- [ ] `make test` shows all tests passing
- [ ] CLI displays usage with `./tile-diff --help`
- [ ] CLI loads test .pivotal files (or skips gracefully if unavailable)
- [ ] Property counts display correctly
- [ ] API client handles auth and SSL correctly
- [ ] Code follows Go best practices (formatting, comments)
- [ ] All files have ABOUTME headers
- [ ] README reflects Phase 1 completion
- [ ] Git history shows incremental, tested commits

---

## Success Criteria

Phase 1 is successful if:

1. **Extraction works**: Can extract metadata.yml from .pivotal ZIP
2. **Parsing works**: Can parse property_blueprints YAML into Go structs
3. **API works**: Can query Ops Manager and parse JSON response
4. **CLI works**: Can accept flags and display property counts
5. **Tests pass**: All unit tests pass with good coverage
6. **Code quality**: Follows Go conventions, has clear comments

**Deliverable Met:** âœ… Go code that reads all three data sources and prints property counts to verify completeness.
